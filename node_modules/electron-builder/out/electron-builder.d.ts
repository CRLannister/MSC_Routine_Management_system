declare module "electron-builder/out/util/log" {
  import BluebirdPromise from "bluebird-lst-c"

  export function warn(message: string): void

  export function log(message: string): void

  export function subTask(title: string, promise: BluebirdPromise<any> | Promise<any>): BluebirdPromise<any>

  export function task(title: string, promise: BluebirdPromise<any> | Promise<any>): BluebirdPromise<any>
}

declare module "electron-builder/out/util/fs" {
  /// <reference types="node" />
  import { Stats } from "fs-extra-p"
  export const MAX_FILE_REQUESTS = 8
  export const CONCURRENCY: {
    concurrency: number
  }
  export type Filter = (file: string, stat: Stats) => boolean

  export function unlinkIfExists(file: string): Promise<string | void>

  export function statOrNull(file: string): Promise<Stats | null>

  export function exists(file: string): Promise<boolean>

  export function walk(initialDirPath: string, filter?: Filter | null, consumer?: (file: string, stat: Stats, parent: string) => any): Promise<Array<string>>

  /**
   * Hard links is used if supported and allowed.
   * File permission is fixed â€” allow execute for all if owner can, allow read for all if owner can.
   */
  export function copyFile(src: string, dest: string, stats?: Stats | null, isUseHardLink?: boolean): Promise<any>

  export class FileCopier {
    private isUseHardLinkFunction
    private isUseHardLink
    constructor(isUseHardLinkFunction?: (file: string) => boolean, isUseHardLink?: boolean)
    copy(src: string, dest: string, stat: Stats | undefined): Promise<void>
  }

  /**
   * Empty directories is never created.
   * Hard links is used if supported and allowed.
   */
  export function copyDir(src: string, destination: string, filter?: Filter, isUseHardLink?: (file: string) => boolean): Promise<any>
}

declare module "electron-builder/out/util/util" {
  /// <reference types="node" />
  import { ChildProcess, SpawnOptions } from "child_process"
  import { DevMetadata } from "electron-builder/out/metadata"
  export const debug: debug.Debugger
  export const debug7z: debug.Debugger

  export interface BaseExecOptions {
    cwd?: string
    env?: any
    stdio?: any
  }

  export interface ExecOptions extends BaseExecOptions {
    customFds?: any
    encoding?: string
    timeout?: number
    maxBuffer?: number
    killSignal?: string
  }

  export function removePassword(input: string): string

  export function execWine(file: string, args: Array<string>, options?: ExecOptions): Promise<string>

  export function prepareArgs(args: Array<string>, exePath: string): string[]

  export function exec(file: string, args?: Array<string> | null, options?: ExecOptions): Promise<string>

  export function doSpawn(command: string, args: Array<string>, options?: SpawnOptions, pipeInput?: Boolean): ChildProcess

  export function spawn(command: string, args?: Array<string> | null, options?: SpawnOptions): Promise<any>

  export function handleProcess(event: string, childProcess: ChildProcess, command: string, resolve: ((value?: any) => void) | null, reject: (reason?: any) => void): void

  export function getElectronVersion(packageData: any, packageJsonPath: string): Promise<string>

  export function computeDefaultAppDirectory(projectDir: string, userAppDir: string | null | undefined): Promise<string>

  export function use<T, R>(value: T | null, task: (it: T) => R): R | null

  export function debug7zArgs(command: "a" | "x"): Array<string>
  export let tmpDirCounter: number

  export function getTempName(prefix?: string | n): string

  export function isEmptyOrSpaces(s: string | n): boolean

  export function asArray<T>(v: n | T | Array<T>): Array<T>

  export function getCacheDirectory(): string

  export function getDirectoriesConfig(m: DevMetadata): any
}

declare module "electron-builder/out/util/promise" {
  import BluebirdPromise from "bluebird-lst-c"

  export function printErrorAndExit(error: Error): void

  export function executeFinally<T>(promise: Promise<T>, task: (errorOccurred: boolean) => Promise<any>): Promise<T>

  export class NestedError extends Error {
    constructor(errors: Array<Error>, message?: string)
  }

  export function all(promises: Array<Promise<any>>): BluebirdPromise<any>
}

declare module "electron-builder/out/util/tmp" {
  
  export class TmpDir {
    private tempPrefixPromise
    private tempFiles
    getTempFile(suffix: string): Promise<string>
    cleanup(): Promise<any>
  }
}

declare module "electron-builder/out/codeSign" {
  import { TmpDir } from "electron-builder/out/util/tmp"
  export const appleCertificatePrefixes: string[]
  export type CertType = "Developer ID Application" | "Developer ID Installer" | "3rd Party Mac Developer Application" | "3rd Party Mac Developer Installer" | "Mac Developer"

  export interface CodeSigningInfo {
    keychainName?: string | null
  }

  export function downloadCertificate(urlOrBase64: string, tmpDir: TmpDir): Promise<string>

  export function createKeychain(tmpDir: TmpDir, cscLink: string, cscKeyPassword: string, cscILink?: string | null, cscIKeyPassword?: string | null): Promise<CodeSigningInfo>

  export function sign(path: string, name: string, keychain: string): Promise<any>
  export let findIdentityRawResult: Promise<Array<string>> | null

  export function findIdentity(certType: CertType, qualifier?: string | null, keychain?: string | null): Promise<string | null>
}

declare module "electron-builder/out/util/binDownload" {
  
  export function getBinFromBintray(name: string, version: string, sha2: string): Promise<string>

  export function getBin(name: string, dirName: string, url: string, sha2: string): Promise<string>
}

declare module "electron-builder/out/options/winOptions" {
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"

  export interface WinBuildOptions extends PlatformSpecificBuildOptions {
    readonly target?: Array<string> | null
    readonly signingHashAlgorithms?: Array<string> | null
    readonly icon?: string | null
    readonly legalTrademarks?: string | null
    readonly certificateFile?: string
    readonly certificatePassword?: string
    readonly certificateSubjectName?: string
    readonly rfc3161TimeStampServer?: string
    readonly timeStampServer?: string
  }

  export interface NsisOptions {
    readonly oneClick?: boolean
    readonly perMachine?: boolean
    readonly allowElevation?: boolean
    readonly runAfterFinish?: boolean
    readonly guid?: string | null
    readonly installerIcon?: string | null
    readonly installerHeader?: string | null
    readonly installerHeaderIcon?: string | null
    readonly include?: string | null
    readonly script?: string | null
    readonly license?: string | null
    readonly language?: string | null
    readonly warningsAsErrors?: boolean
    readonly menuCategory?: boolean | string
  }

  export interface SquirrelWindowsOptions extends WinBuildOptions {
    readonly iconUrl?: string | null
    readonly loadingGif?: string | null
    readonly msi?: boolean
    readonly remoteReleases?: string | boolean | null
    readonly remoteToken?: string | null
    readonly useAppIdAsId?: boolean
  }

  export interface AppXOptions {
    readonly backgroundColor?: string | null
    readonly makeappxArgs?: Array<string> | null
    readonly publisher?: string | null
    readonly displayName?: string | null
    readonly publisherDisplayName?: string | null
    readonly identityName?: string | null
  }
}

declare module "electron-builder/out/windowsCodeSign" {
  import { WinBuildOptions } from "electron-builder/out/options/winOptions"

  export function getSignVendorPath(): Promise<string>

  export interface SignOptions {
    readonly path: string
    readonly cert?: string | null
    readonly subjectName?: string | null
    readonly name?: string | null
    readonly password?: string | null
    readonly site?: string | null
    readonly options: WinBuildOptions
  }

  export function sign(options: SignOptions): Promise<void>
}

declare module "electron-builder/out/repositoryInfo" {
  import { Info } from "hosted-git-info"
  import { AppMetadata, Metadata } from "electron-builder/out/metadata"

  export interface RepositorySlug {
    user: string
    project: string
  }

  export function getRepositoryInfo(metadata?: AppMetadata, devMetadata?: Metadata): Promise<Info | null>
}

declare module "electron-builder/out/targets/squirrelPack" {
  import { WinPackager } from "electron-builder/out/winPackager"

  export function convertVersion(version: string): string

  export interface SquirrelOptions {
    vendorPath: string
    remoteReleases?: string
    remoteToken?: string
    loadingGif?: string
    productName?: string
    appId?: string
    name: string
    packageCompressionLevel?: number
    version: string
    msi?: any
    owners?: string
    description?: string
    iconUrl?: string
    authors?: string
    extraMetadataSpecs?: string
    copyright?: string
  }

  export function buildInstaller(options: SquirrelOptions, outputDirectory: string, setupExe: string, packager: WinPackager, appOutDir: string): Promise<void>
}

declare module "electron-builder/out/targets/archive" {
  import { CompressionLevel } from "electron-builder/out/metadata"

  export function tar(compression: CompressionLevel | n, format: string, outFile: string, dirToArchive: string, isMacApp?: boolean): Promise<string>

  export function archive(compression: CompressionLevel | n, format: string, outFile: string, dirToArchive: string, withoutDir?: boolean): Promise<string>
}

declare module "electron-builder/out/targets/targetFactory" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { Arch } from "electron-builder/out/metadata"
  export const DEFAULT_TARGET = "default"
  export const DIR_TARGET = "dir"

  export abstract class Target {
    readonly name: string
    readonly isAsyncSupported: boolean
    constructor(name: string, isAsyncSupported?: boolean)
    abstract build(appOutDir: string, arch: Arch): Promise<any>
    finishBuild(): Promise<any>
  }

  export function createTargets(nameToTarget: Map<String, Target>, rawList: Array<string> | n, outDir: string, packager: PlatformPackager<any>, cleanupTasks: Array<() => Promise<any>>): Array<Target>

  export function createCommonTarget(target: string, outDir: string, packager: PlatformPackager<any>): Target

  export class NoOpTarget extends Target {
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/squirrelWindows" {
  import { WinPackager } from "electron-builder/out/winPackager"
  import { Arch } from "electron-builder/out/metadata"
  import { SquirrelOptions } from "electron-builder/out/targets/squirrelPack"
  import { Target } from "electron-builder/out/targets/targetFactory"

  export default class SquirrelWindowsTarget extends Target {
    private readonly packager
    private readonly outDir
    private readonly options
    constructor(packager: WinPackager, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<void>
    computeEffectiveDistOptions(): Promise<SquirrelOptions>
  }
}

declare module "electron-builder/out/targets/appx" {
  import { Arch } from "electron-builder/out/metadata"
  import { WinPackager } from "electron-builder/out/winPackager"
  import { Target } from "electron-builder/out/targets/targetFactory"

  export default class AppXTarget extends Target {
    private readonly packager
    private readonly outDir
    private readonly options
    constructor(packager: WinPackager, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
    private writeManifest(templatePath, preAppx, safeName, arch)
  }
}

declare module "electron-builder/out/targets/nsis" {
  import { WinPackager } from "electron-builder/out/winPackager"
  import { Arch } from "electron-builder/out/metadata"
  import BluebirdPromise from "bluebird-lst-c"
  import { Target } from "electron-builder/out/targets/targetFactory"

  export default class NsisTarget extends Target {
    private packager
    private outDir
    private readonly options
    private archs
    private readonly nsisTemplatesDir
    private readonly publishConfigs
    constructor(packager: WinPackager, outDir: string)
    private computePublishConfigs()
    build(appOutDir: string, arch: Arch): BluebirdPromise<null>
    private doBuild(appOutDir, arch)
    finishBuild(): Promise<any>
    private buildInstaller()
    private executeMakensis(defines, commands, isInstaller, originalScript)
  }
}

declare module "electron-builder/out/winPackager" {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform } from "electron-builder/out/metadata"
  import { SignOptions } from "electron-builder/out/windowsCodeSign"
  import { Target } from "electron-builder/out/targets/targetFactory"
  import { WinBuildOptions } from "electron-builder/out/options/winOptions"

  export interface FileCodeSigningInfo {
    readonly file?: string | null
    readonly password?: string | null
    readonly subjectName?: string | null
  }

  export class WinPackager extends PlatformPackager<WinBuildOptions> {
    readonly cscInfo: Promise<FileCodeSigningInfo | null> | null
    private iconPath
    constructor(info: BuildInfo)
    readonly defaultTarget: Array<string>
    protected doGetCscPassword(): string
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void, cleanupTasks: Array<() => Promise<any>>): void
    readonly platform: Platform
    getIconPath(): Promise<string>
    private getValidIconPath()
    sign(file: string): Promise<void>
    protected doSign(options: SignOptions): Promise<any>
    signAndEditResources(file: string): Promise<void>
    protected postInitApp(appOutDir: string): Promise<void>
  }
}

declare module "electron-builder/out/errorMessages" {
  export const buildIsMissed: string
  export const authorEmailIsMissed: string
  export const buildInAppSpecified: string
  export const nameInBuildSpecified: string
}

declare module "electron-builder/out/util/deepAssign" {
  
  export function deepAssign(target: any, ...objects: Array<any>): any
}

declare module "electron-builder/out/options/macOptions" {
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  export type MacOsTargetName = "default" | "dmg" | "mas" | "pkg" | "7z" | "zip" | "tar.xz" | "tar.lz" | "tar.gz" | "tar.bz2" | "dir"

  export interface MacOptions extends PlatformSpecificBuildOptions {
    readonly category?: string | null
    readonly target?: Array<MacOsTargetName> | null
    readonly identity?: string | null
    readonly icon?: string | null
    readonly entitlements?: string | null
    readonly entitlementsInherit?: string | null
    readonly bundleVersion?: string | null
    readonly helperBundleId?: string | null
  }

  export interface DmgOptions {
    readonly background?: string | null
    readonly backgroundColor?: string | null
    readonly icon?: string | null
    readonly iconSize?: number | null
    readonly iconTextSize?: number | null
    readonly title?: string | null
    readonly contents?: Array<DmgContent>
    readonly format?: string
    window?: DmgWindow
  }

  export interface DmgWindow {
    x?: number
    y?: number
    /**
     * The width. Defaults to background image width or 540.
     */
    width?: number
    /**
     * The height. Defaults to background image height or 380.
     */
    height?: number
  }

  export interface DmgContent {
    x: number
    y: number
    type?: "link" | "file"
    name?: string
    path?: string
  }

  export interface MasBuildOptions extends MacOptions {
    readonly entitlements?: string | null
    readonly entitlementsInherit?: string | null
  }
}

declare module "electron-builder/out/targets/dmg" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { MacOptions, DmgOptions } from "electron-builder/out/options/macOptions"
  import { Arch } from "electron-builder/out/metadata"
  import { Target } from "electron-builder/out/targets/targetFactory"

  export class DmgTarget extends Target {
    private packager
    private helperDir
    constructor(packager: PlatformPackager<MacOptions>)
    build(appOutDir: string, arch: Arch): Promise<void>
    computeVolumeName(custom?: string | null): string
    computeDmgOptions(): Promise<DmgOptions>
  }

  export function attachAndExecute(dmgPath: string, readWrite: boolean, task: () => Promise<any>): Promise<void>
}

declare module "electron-builder/out/targets/pkg" {
  import { Arch } from "electron-builder/out/metadata"
  import MacPackager from "electron-builder/out/macPackager"
  import { Target } from "electron-builder/out/targets/targetFactory"

  export class PkgTarget extends Target {
    private packager
    constructor(packager: MacPackager)
    build(appOutDir: string, arch: Arch): Promise<any>
  }

  export function prepareProductBuildArgs(appPath: string, identity: string, keychain: string | n): string[]
}

declare module "electron-builder/out/macPackager" {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform, Arch } from "electron-builder/out/metadata"
  import { MacOptions } from "electron-builder/out/options/macOptions"
  import { CodeSigningInfo } from "electron-builder/out/codeSign"
  import { SignOptions } from "electron-macos-sign"
  import { Target } from "electron-builder/out/targets/targetFactory"
  import { AppInfo } from "electron-builder/out/appInfo"

  export default class MacPackager extends PlatformPackager<MacOptions> {
    readonly codeSigningInfo: Promise<CodeSigningInfo>
    constructor(info: BuildInfo)
    readonly defaultTarget: Array<string>
    protected prepareAppInfo(appInfo: AppInfo): AppInfo
    getIconPath(): Promise<string | null>
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void, cleanupTasks: Array<() => Promise<any>>): void
    readonly platform: Platform
    pack(outDir: string, arch: Arch, targets: Array<Target>, postAsyncTasks: Array<Promise<any>>): Promise<any>
    private sign(appOutDir, masOptions)
    findInstallerIdentity(isMas: boolean, keychainName: string | n): Promise<string>
    protected doSign(opts: SignOptions): Promise<any>
    protected doFlat(appPath: string, outFile: string, identity: string, keychain: string | n): Promise<any>
  }
}

declare module "electron-builder/out/util/readPackageJson" {
  
  export function readPackageJson(file: string): Promise<any>
}

declare module "electron-builder/out/publish/uploader" {
  /// <reference types="node" />
  import { Stats } from "fs-extra-p"
  import { ClientRequest } from "http"

  export function uploadFile(file: string, fileStat: Stats, fileName: string, request: ClientRequest, reject: (error: Error) => void): void
}

declare module "electron-builder/out/publish/publisher" {
  /// <reference types="node" />
  import { ClientRequest } from "http"
  export type PublishPolicy = "onTag" | "onTagOrDraft" | "always" | "never"

  export interface PublishOptions {
    publish?: PublishPolicy | null
    draft?: boolean
    prerelease?: boolean
  }

  export abstract class Publisher {
    upload(file: string, artifactName?: string): Promise<any>
    uploadData(data: Buffer, fileName: string): Promise<any>
    protected abstract doUpload(fileName: string, dataLength: number, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): Promise<any>
  }
}

declare module "electron-builder/out/util/nodeHttpExecutor" {
  /// <reference types="node" />
  import { ClientRequest } from "http"
  import { HttpExecutor, DownloadOptions } from "electron-builder-http"
  import { RequestOptions } from "https"

  export class NodeHttpExecutor extends HttpExecutor<RequestOptions, ClientRequest> {
    private httpsAgentPromise
    download(url: string, destination: string, options?: DownloadOptions | null): Promise<string>
    private addTimeOutHandler(request, callback)
    private doDownload(url, destination, redirectCount, options, agent, callback)
    doApiRequest<T>(options: RequestOptions, token: string | null, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void, redirectCount?: number): Promise<T>
  }
}

declare module "electron-builder/out/publish/gitHubPublisher" {
  /// <reference types="node" />
  import { PublishOptions, Publisher } from "electron-builder/out/publish/publisher"
  import { GithubOptions } from "electron-builder-http/out/publishOptions"
  import { ClientRequest } from "http"

  export interface Release {
    id: number
    tag_name: string
    draft: boolean
    upload_url: string
  }

  export class GitHubPublisher extends Publisher {
    private readonly info
    private readonly version
    private readonly options
    private readonly isPublishOptionGuessed
    private tag
    private _releasePromise
    private readonly httpExecutor
    private readonly token
    private readonly policy
    readonly releasePromise: Promise<Release | null>
    constructor(info: GithubOptions, version: string, options?: PublishOptions, isPublishOptionGuessed?: boolean)
    private init()
    protected doUpload(fileName: string, dataLength: number, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): Promise<void>
    private createRelease()
    getRelease(): Promise<any>
    deleteRelease(): Promise<any>
  }
}

declare module "electron-builder/out/publish/BintrayPublisher" {
  /// <reference types="node" />
  import { Publisher, PublishOptions } from "electron-builder/out/publish/publisher"
  import { BintrayOptions } from "electron-builder-http/out/publishOptions"
  import { ClientRequest } from "http"

  export class BintrayPublisher extends Publisher {
    private readonly version
    private readonly options
    private _versionPromise
    private readonly httpExecutor
    private readonly client
    constructor(info: BintrayOptions, version: string, options?: PublishOptions)
    private init()
    protected doUpload(fileName: string, dataLength: number, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): Promise<any>
    deleteRelease(): Promise<any>
  }
}

declare module "electron-builder/out/builder" {
  import { Packager } from "electron-builder/out/packager"
  import { PackagerOptions } from "electron-builder/out/platformPackager"
  import { PublishOptions, Publisher } from "electron-builder/out/publish/publisher"
  import { Platform, Arch } from "electron-builder/out/metadata"
  import { PublishConfiguration, GithubOptions, BintrayOptions } from "electron-builder-http/out/publishOptions"

  export interface BuildOptions extends PackagerOptions, PublishOptions {
  }

  export interface CliOptions extends PackagerOptions, PublishOptions {
    mac?: Array<string>
    linux?: Array<string>
    win?: Array<string>
    arch?: string
    x64?: boolean
    ia32?: boolean
    armv7l?: boolean
    dir?: boolean
    platform?: string
    project?: string
  }

  export function normalizeOptions(args: CliOptions): BuildOptions

  export function createTargets(platforms: Array<Platform>, type?: string | null, arch?: string | null): Map<Platform, Map<Arch, Array<string>>>

  export function build(rawOptions?: CliOptions): Promise<Array<string>>

  export function createPublisher(packager: Packager, publishConfig: PublishConfiguration | GithubOptions | BintrayOptions, options: PublishOptions, isPublishOptionGuessed?: boolean): Promise<Publisher | null>
}

declare module "electron-builder/out/yarn" {
  import { BuildMetadata } from "electron-builder/out/metadata"

  export function installOrRebuild(options: BuildMetadata, appDir: string, electronVersion: string, platform: string, arch: string, forceInstall?: boolean): Promise<void>

  export function getGypEnv(electronVersion: string, platform: string, arch: string, buildFromSource: boolean): any

  export function dependencies(dir: string, extraneousOnly: boolean, result: Set<string>): Promise<Array<string>>

  export function rebuild(appDir: string, electronVersion: string, platform: string, arch: string, additionalArgs: Array<string>, buildFromSource: boolean): Promise<void>
}

declare module "electron-builder/out/packager" {
  /// <reference types="node" />
  import { EventEmitter } from "events"
  import { AppMetadata, DevMetadata, Platform, BuildMetadata } from "electron-builder/out/metadata"
  import { BuildInfo, ArtifactCreated } from "electron-builder/out/platformPackager"
  import { AppInfo } from "electron-builder/out/appInfo"
  import { Target } from "electron-builder/out/targets/targetFactory"
  import { TmpDir } from "electron-builder/out/util/tmp"
  import { BuildOptions } from "electron-builder/out/builder"

  export class Packager implements BuildInfo {
    options: BuildOptions
    readonly projectDir: string
    appDir: string
    metadata: AppMetadata
    devMetadata: DevMetadata
    readonly config: BuildMetadata
    isTwoPackageJsonProjectLayoutUsed: boolean
    electronVersion: string
    readonly eventEmitter: EventEmitter
    appInfo: AppInfo
    readonly tempDirManager: TmpDir
    constructor(options: BuildOptions)
    artifactCreated(handler: (event: ArtifactCreated) => void): Packager
    readonly devPackageFile: string
    build(): Promise<Map<Platform, Map<String, Target>>>
    private doBuild(cleanupTasks)
    private createHelper(platform, cleanupTasks)
    private checkMetadata(appPackageFile, devAppPackageFile)
    private installAppDependencies(platform, arch)
  }

  export function normalizePlatforms(rawPlatforms: Array<string | Platform> | string | Platform | n): Array<Platform>

  export function checkWineVersion(checkPromise: Promise<string>): Promise<void>
}

declare module "electron-builder/out/asarUtil" {
  import { AsarOptions } from "asar-electron-builder"
  import { Filter } from "electron-builder/out/util/fs"

  export function createAsarArchive(src: string, resourcesPath: string, options: AsarOptions, filter: Filter, unpackPattern: Filter | null): Promise<any>

  export function checkFileInArchive(asarFile: string, relativeFile: string, messagePrefix: string): Promise<void>
}

declare module "electron-builder/out/packager/dirPackager" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export function unpackElectron(packager: PlatformPackager<any>, out: string, platform: string, arch: string, electronVersion: string): Promise<void>
}

declare module "electron-builder/out/util/filter" {
  import { Minimatch } from "minimatch"
  import { Filter } from "electron-builder/out/util/fs"

  export function hasMagic(pattern: Minimatch): boolean

  export function createFilter(src: string, patterns: Array<Minimatch>, ignoreFiles?: Set<string>, rawFilter?: (file: string) => boolean, excludePatterns?: Array<Minimatch> | null): Filter
}

declare module "electron-builder/out/fileMatcher" {
  import { Minimatch } from "minimatch"
  import { Filter } from "electron-builder/out/util/fs"

  export interface FilePattern {
    from?: string
    to?: string
    filter?: Array<string> | string
  }

  export interface FileMatchOptions {
    arch: string
    os: string
  }

  export class FileMatcher {
    private options
    readonly from: string
    readonly to: string
    readonly patterns: Array<string>
    constructor(from: string, to: string, options: FileMatchOptions, patterns?: Array<string> | string | n)
    addPattern(pattern: string): void
    addAllPattern(): void
    isEmpty(): boolean
    containsOnlyIgnore(): boolean
    getParsedPatterns(fromDir?: string): Array<Minimatch>
    createFilter(ignoreFiles?: Set<string>, rawFilter?: (file: string) => boolean, excludePatterns?: Array<Minimatch> | n): Filter
    private expandPattern(pattern)
  }

  export function deprecatedUserIgnoreFilter(ignore: Array<RegExp> | ((file: string) => boolean), appDir: string): (file: string) => any
}

declare module "electron-builder/out/platformPackager" {
  /// <reference types="node" />
  import { AppMetadata, DevMetadata, Platform, PlatformSpecificBuildOptions, Arch, FileAssociation, BuildMetadata } from "electron-builder/out/metadata"
  import { Packager } from "electron-builder/out/packager"
  import { AppInfo } from "electron-builder/out/appInfo"
  import { TmpDir } from "electron-builder/out/util/tmp"
  import { BuildOptions } from "electron-builder/out/builder"
  import { PublishConfiguration, GithubOptions, BintrayOptions, GenericServerOptions } from "electron-builder-http/out/publishOptions"
  import { Target } from "electron-builder/out/targets/targetFactory"
  import EventEmitter = NodeJS.EventEmitter

  export interface PackagerOptions {
    targets?: Map<Platform, Map<Arch, string[]>>
    projectDir?: string | null
    cscLink?: string | null
    cscKeyPassword?: string | null
    cscInstallerLink?: string | null
    cscInstallerKeyPassword?: string | null
    platformPackagerFactory?: ((packager: Packager, platform: Platform, cleanupTasks: Array<() => Promise<any>>) => PlatformPackager<any>) | null
    /**
     * The same as [development package.json](https://github.com/electron-userland/electron-builder/wiki/Options#development-packagejson).
     *
     * Development `package.json` will be still read, but options specified in this object will override.
     */
    readonly devMetadata?: DevMetadata
    readonly config?: BuildMetadata
    /**
     * The same as [application package.json](https://github.com/electron-userland/electron-builder/wiki/Options#AppMetadata).
     *
     * Application `package.json` will be still read, but options specified in this object will override.
     */
    readonly appMetadata?: AppMetadata
    readonly effectiveOptionComputed?: (options: any) => Promise<boolean>
    readonly extraMetadata?: any
    readonly prepackaged?: string
  }

  export interface BuildInfo {
    options: BuildOptions
    metadata: AppMetadata
    devMetadata: DevMetadata
    config: BuildMetadata
    projectDir: string
    appDir: string
    devPackageFile: string
    electronVersion: string
    eventEmitter: EventEmitter
    isTwoPackageJsonProjectLayoutUsed: boolean
    appInfo: AppInfo
    readonly tempDirManager: TmpDir
  }

  export abstract class PlatformPackager<DC extends PlatformSpecificBuildOptions> {
    readonly info: BuildInfo
    readonly options: PackagerOptions
    readonly projectDir: string
    readonly buildResourcesDir: string
    readonly config: BuildMetadata
    readonly platformSpecificBuildOptions: DC
    readonly resourceList: Promise<Array<string>>
    readonly abstract platform: Platform
    readonly appInfo: AppInfo
    constructor(info: BuildInfo)
    readonly abstract defaultTarget: Array<string>
    protected prepareAppInfo(appInfo: AppInfo): AppInfo
    normalizePlatformSpecificBuildOptions(options: DC | n): DC
    abstract createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void, cleanupTasks: Array<() => Promise<any>>): void
    protected getCscPassword(): string
    protected doGetCscPassword(): any
    readonly relativeBuildResourcesDirname: any
    protected computeAppOutDir(outDir: string, arch: Arch): string
    dispatchArtifactCreated(file: string, artifactName?: string): void
    pack(outDir: string, arch: Arch, targets: Array<Target>, postAsyncTasks: Array<Promise<any>>): Promise<any>
    protected packageInDistributableFormat(appOutDir: string, arch: Arch, targets: Array<Target>, postAsyncTasks: Array<Promise<any>>): void
    private getExtraFileMatchers(isResources, appOutDir, fileMatchOptions, customBuildOptions)
    protected doPack(outDir: string, appOutDir: string, platformName: string, arch: Arch, platformSpecificBuildOptions: DC): Promise<void>
    protected postInitApp(executableFile: string): Promise<any>
    getIconPath(): Promise<string | null>
    private computeAsarOptions(customBuildOptions)
    private doCopyExtraFiles(patterns)
    private getFileMatchers(name, defaultSrc, defaultDest, allowAdvancedMatching, fileMatchOptions, customBuildOptions)
    private getResourcesDir(appOutDir)
    private getOSXResourcesDir(appOutDir)
    private checkFileInPackage(resourcesDir, file, messagePrefix, isAsar)
    private sanityCheckPackage(appOutDir, isAsar)
    generateName(ext: string | null, arch: Arch, deployment: boolean, classifier?: string | null): string
    generateName2(ext: string | null, classifier: string | n, deployment: boolean): string
    getDefaultIcon(ext: string): Promise<string | null>
    getTempFile(suffix: string): Promise<string>
    getFileAssociations(): Array<FileAssociation>
    getResource(custom: string | n, ...names: Array<string>): Promise<string | null>
  }

  export function getArchSuffix(arch: Arch): string

  export interface ArtifactCreated {
    readonly packager: PlatformPackager<any>
    readonly file?: string
    readonly data?: Buffer
    readonly artifactName?: string
    readonly publishConfig?: PublishConfiguration
  }

  export function smarten(s: string): string

  export function normalizeExt(ext: string): string

  export function getPublishConfigs(packager: PlatformPackager<any>, platformSpecificBuildOptions: PlatformSpecificBuildOptions): Array<PublishConfiguration> | null

  export function getResolvedPublishConfig(packager: BuildInfo, publishConfig: PublishConfiguration | GithubOptions | BintrayOptions | GenericServerOptions, errorIfCannot: boolean): Promise<PublishConfiguration | null>

  export function toDebArch(arch: Arch): "amd64" | "i386"
}

declare module "electron-builder/out/options/linuxOptions" {
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"

  export interface LinuxBuildOptions extends PlatformSpecificBuildOptions {
    readonly category?: string | null
    readonly packageCategory?: string | null
    readonly description?: string | null
    readonly target?: Array<string> | null
    readonly synopsis?: string | null
    readonly maintainer?: string | null
    readonly vendor?: string | null
    readonly fpm?: Array<string> | null
    /**
     The [Desktop file](https://developer.gnome.org/integration-guide/stable/desktop-files.html.en) entries (name to value).
     */
    readonly desktop?: {
      [key: string]: string
    } | null
    readonly afterInstall?: string | null
    readonly afterRemove?: string | null
    readonly compression?: string | null
    readonly depends?: string[] | null
    readonly executableName?: string | null
  }

  export interface SnapOptions extends LinuxBuildOptions {
    confinement?: "devmode" | "strict" | null
    summary?: string | null
    grade?: "devel" | "stable" | null
    assumes?: Array<string> | null
    stagePackages?: Array<string> | null
    ubuntuAppPlatformContent?: string | null
  }
}

declare module "electron-builder/out/metadata" {
  import { AsarOptions } from "asar-electron-builder"
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { MacOptions, DmgOptions, MasBuildOptions } from "electron-builder/out/options/macOptions"
  import { Publish } from "electron-builder-http/out/publishOptions"
  import { WinBuildOptions, NsisOptions, SquirrelWindowsOptions, AppXOptions } from "electron-builder/out/options/winOptions"
  import { LinuxBuildOptions, SnapOptions } from "electron-builder/out/options/linuxOptions"

  export interface Metadata {
    readonly repository?: string | RepositoryInfo | null
    dependencies?: {
      [key: string]: string
    }
  }

  export interface AppMetadata extends Metadata {
    readonly version?: string
    readonly name: string
    readonly productName?: string | null
    readonly description?: string
    readonly main?: string | null
    readonly author?: AuthorMetadata
    readonly homepage?: string | null
    readonly license?: string | null
  }

  export interface DevMetadata extends Metadata {
    readonly build: BuildMetadata
  }

  export interface RepositoryInfo {
    readonly url: string
  }

  export interface AuthorMetadata {
    readonly name: string
    readonly email?: string
  }
  export type CompressionLevel = "store" | "normal" | "maximum"

  export interface BuildMetadata {
    readonly appId?: string | null
    readonly copyright?: string | null
    readonly iconUrl?: string | null
    readonly productName?: string | null
    /**
     A [glob patterns](https://www.npmjs.com/package/glob#glob-primer) relative to the [app directory](#MetadataDirectories-app), which specifies which files to include when copying files to create the package.
  
     See [File Patterns](#multiple-glob-patterns).
     */
    readonly files?: Array<string> | string | null
    readonly extraResources?: Array<string> | string | null
    readonly extraFiles?: Array<string> | string | null
    readonly asar?: AsarOptions | boolean | null
    /**
     A [glob patterns](https://www.npmjs.com/package/glob#glob-primer) relative to the [app directory](#MetadataDirectories-app), which specifies which files to unpack when creating the [asar](http://electron.atom.io/docs/tutorial/application-packaging/) archive.
     */
    readonly asarUnpack?: Array<string> | string | null
    readonly fileAssociations?: Array<FileAssociation> | FileAssociation
    readonly protocols?: Array<Protocol> | Protocol
    readonly mac?: MacOptions | null
    readonly dmg?: DmgOptions | null
    readonly mas?: MasBuildOptions | null
    readonly win?: WinBuildOptions | null
    readonly nsis?: NsisOptions | null
    readonly squirrelWindows?: SquirrelWindowsOptions | null
    readonly appx?: AppXOptions | null
    readonly linux?: LinuxBuildOptions | null
    readonly deb?: LinuxBuildOptions | null
    readonly snap?: SnapOptions | null
    readonly compression?: CompressionLevel | null
    readonly afterPack?: (context: AfterPackContext) => Promise<any> | null
    readonly npmRebuild?: boolean
    readonly npmSkipBuildFromSource?: boolean
    readonly npmArgs?: Array<string> | string | null
    readonly nodeGypRebuild?: boolean
    readonly electronDist?: string
    readonly electronDownload?: any
    readonly icon?: string | null
    readonly "app-bundle-id"?: string | null
    readonly publish?: Publish
    readonly forceCodeSigning?: boolean
    readonly directories?: MetadataDirectories | null
  }

  export interface AfterPackContext {
    readonly appOutDir: string
    readonly options: any
    readonly packager: PlatformPackager<any>
  }

  export interface FileAssociation {
    readonly ext: string | Array<string>
    readonly name: string
    readonly description?: string
    readonly icon?: string
    readonly role?: string
    readonly isPackage?: boolean
  }

  export interface Protocol {
    readonly name: string
    readonly role?: string
    readonly schemes: Array<string>
  }

  export interface MetadataDirectories {
    readonly buildResources?: string | null
    readonly output?: string | null
    readonly app?: string | null
  }

  export interface PlatformSpecificBuildOptions {
    readonly files?: Array<string> | null
    readonly extraFiles?: Array<string> | null
    readonly extraResources?: Array<string> | null
    readonly asarUnpack?: Array<string> | null
    readonly asar?: AsarOptions | boolean
    readonly target?: Array<string> | null
    readonly icon?: string | null
    readonly fileAssociations?: Array<FileAssociation> | FileAssociation
    readonly publish?: Publish
    readonly forceCodeSigning?: boolean
  }

  export class Platform {
    name: string
    buildConfigurationKey: string
    nodeName: string
    static MAC: Platform
    static LINUX: Platform
    static WINDOWS: Platform
    static OSX: Platform
    constructor(name: string, buildConfigurationKey: string, nodeName: string)
    toString(): string
    createTarget(type?: string | Array<string> | null, ...archs: Array<Arch>): Map<Platform, Map<Arch, Array<string>>>
    static current(): Platform
    static fromString(name: string): Platform
  }
  export enum Arch {
    ia32 = 0,
    x64 = 1,
    armv7l = 2,
  }

  export function toLinuxArchString(arch: Arch): "amd64" | "i386" | "armv7l"

  export function archFromString(name: string): Arch
}

declare module "electron-builder/out/appInfo" {
  import { DevMetadata, AppMetadata } from "electron-builder/out/metadata"

  export class AppInfo {
    metadata: AppMetadata
    private devMetadata
    readonly description: string
    readonly version: string
    readonly buildNumber: string
    readonly buildVersion: string
    readonly productName: string
    readonly productFilename: string
    private readonly config
    constructor(metadata: AppMetadata, devMetadata: DevMetadata, buildVersion?: string | null)
    readonly versionInWeirdWindowsForm: string
    readonly companyName: string
    readonly id: string
    readonly name: string
    readonly copyright: string
    computePackageUrl(): Promise<string | null>
  }
}

declare module "electron-builder/out/cli/cliOptions" {
  
  export function createYargs(): any
}

declare module "electron-builder" {
  export { Packager } from "electron-builder/out/packager"
  export { PackagerOptions, ArtifactCreated, BuildInfo, getArchSuffix } from "electron-builder/out/platformPackager"
  export { DIR_TARGET, DEFAULT_TARGET, Target } from "electron-builder/out/targets/targetFactory"
  export { BuildOptions, build, CliOptions, createTargets } from "electron-builder/out/builder"
  export { PublishOptions, Publisher } from "electron-builder/out/publish/publisher"
  export { AppMetadata, DevMetadata, Platform, Arch, archFromString, BuildMetadata, CompressionLevel } from "electron-builder/out/metadata"
  export { MacOptions, DmgOptions, MasBuildOptions, MacOsTargetName } from "electron-builder/out/options/macOptions"
  export { WinBuildOptions, NsisOptions, SquirrelWindowsOptions, AppXOptions } from "electron-builder/out/options/winOptions"
  export { LinuxBuildOptions } from "electron-builder/out/options/linuxOptions"
}

declare module "electron-builder/out/targets/LinuxTargetHelper" {
  import { LinuxBuildOptions } from "electron-builder/out/options/linuxOptions"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  export const installPrefix = "/opt"

  export class LinuxTargetHelper {
    private packager
    readonly icons: Promise<Array<Array<string>>>
    maxIconPath: string | null
    constructor(packager: LinuxPackager)
    private computeDesktopIcons()
    private iconsFromDir(iconsDir)
    private getIcns()
    getDescription(options: LinuxBuildOptions): string
    computeDesktopEntry(platformSpecificBuildOptions: LinuxBuildOptions, exec?: string, destination?: string | null, extra?: {
      [key: string]: string
    }): Promise<string>
    private createFromIcns(tempDir)
    private createMappings(tempDir)
  }
}

declare module "electron-builder/out/targets/fpm" {
  import { Arch } from "electron-builder/out/metadata"
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { Target } from "electron-builder/out/targets/targetFactory"

  export default class FpmTarget extends Target {
    private packager
    private helper
    private outDir
    private readonly options
    private readonly scriptFiles
    private readonly desktopEntry
    constructor(name: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    private createScripts()
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/appImage" {
  import { Arch } from "electron-builder/out/metadata"
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { Target } from "electron-builder/out/targets/targetFactory"

  export default class AppImageTarget extends Target {
    private packager
    private helper
    private outDir
    private readonly options
    private readonly desktopEntry
    constructor(ignored: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/snap" {
  import { Arch } from "electron-builder/out/metadata"
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { Target } from "electron-builder/out/targets/targetFactory"

  export default class SnapTarget extends Target {
    private packager
    private helper
    private outDir
    private readonly options
    constructor(name: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/linuxPackager" {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform } from "electron-builder/out/metadata"
  import { Target } from "electron-builder/out/targets/targetFactory"
  import { LinuxBuildOptions } from "electron-builder/out/options/linuxOptions"

  export class LinuxPackager extends PlatformPackager<LinuxBuildOptions> {
    readonly executableName: string
    constructor(info: BuildInfo)
    readonly defaultTarget: Array<string>
    normalizePlatformSpecificBuildOptions(options: LinuxBuildOptions | n): LinuxBuildOptions
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void, cleanupTasks: Array<() => Promise<any>>): void
    readonly platform: Platform
    protected postInitApp(appOutDir: string): Promise<any>
  }
}

declare module "electron-builder/out/packager/mac" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export function createApp(packager: PlatformPackager<any>, appOutDir: string): Promise<void>
}

