"use strict";

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

let main = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
        const args = (_yargs || _load_yargs()).default.option("publisher", {
            alias: ["p"]
        }).argv;
        const tmpDir = new (_tmp || _load_tmp()).TmpDir();
        const targetDir = process.cwd();
        const tempPrefix = _path.join((yield tmpDir.getTempFile("")), (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(args.publisher));
        const cer = `${ tempPrefix }.cer`;
        const pvk = `${ tempPrefix }.pvk`;
        (0, (_log || _load_log()).log)('When asked to enter a password ("Create Private Key Password"), please select "None".');
        const vendorPath = _path.join((yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)()), "windows-10", process.arch);
        yield (0, (_util || _load_util()).exec)(_path.join(vendorPath, "makecert.exe"), ["-r", "-h", "0", "-n", `CN=${ args.publisher }`, "-eku", "1.3.6.1.5.5.7.3.3", "-pe", "-sv", pvk, cer]);
        const pfx = _path.join(targetDir, `${ (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(args.publisher) }.pfx`);
        yield (0, (_fs || _load_fs()).unlinkIfExists)(pfx);
        yield (0, (_util || _load_util()).exec)(_path.join(vendorPath, "pvk2pfx.exe"), ["-pvk", pvk, "-spc", cer, "-pfx", pfx]);
        (0, (_log || _load_log()).log)(`${ pfx } created. Please see https://github.com/electron-userland/electron-builder/wiki/Code-Signing how do use it to sign.`);
        const certLocation = "Cert:\\LocalMachine\\TrustedPeople";
        (0, (_log || _load_log()).log)(`${ pfx } will be imported into ${ certLocation } Operation will be succeed only if runned from root. Otherwise import file manually.`);
        yield (0, (_util || _load_util()).spawn)("powershell.exe", ["Import-PfxCertificate", "-FilePath", `"${ pfx }"`, "-CertStoreLocation", ""]);
        tmpDir.cleanup();
    });

    return function main() {
        return _ref.apply(this, arguments);
    };
})();

var _yargs;

function _load_yargs() {
    return _yargs = _interopRequireDefault(require("yargs"));
}

var _promise;

function _load_promise() {
    return _promise = require("../util/promise");
}

var _util;

function _load_util() {
    return _util = require("../util/util");
}

var _windowsCodeSign;

function _load_windowsCodeSign() {
    return _windowsCodeSign = require("../windowsCodeSign");
}

var _path = _interopRequireWildcard(require("path"));

var _sanitizeFilename;

function _load_sanitizeFilename() {
    return _sanitizeFilename = _interopRequireDefault(require("sanitize-filename"));
}

var _log;

function _load_log() {
    return _log = require("../util/log");
}

var _tmp;

function _load_tmp() {
    return _tmp = require("../util/tmp");
}

var _fs;

function _load_fs() {
    return _fs = require("../util/fs");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

main().catch((_promise || _load_promise()).printErrorAndExit);
//# sourceMappingURL=create-self-signed-cert.js.map