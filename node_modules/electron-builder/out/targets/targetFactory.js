"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoOpTarget = exports.Target = exports.DIR_TARGET = exports.DEFAULT_TARGET = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

exports.createTargets = createTargets;
exports.createCommonTarget = createCommonTarget;

var _metadata;

function _load_metadata() {
    return _metadata = require("../metadata");
}

var _archive;

function _load_archive() {
    return _archive = require("./archive");
}

var _path = _interopRequireWildcard(require("path"));

var _log;

function _load_log() {
    return _log = require("../util/log");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const archiveTargets = new Set(["zip", "7z", "tar.xz", "tar.lz", "tar.gz", "tar.bz2"]);
const DEFAULT_TARGET = exports.DEFAULT_TARGET = "default";
const DIR_TARGET = exports.DIR_TARGET = "dir";
class Target {
    constructor(name) {
        let isAsyncSupported = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        this.name = name;
        this.isAsyncSupported = isAsyncSupported;
    }
    finishBuild() {
        return (_bluebirdLstC2 || _load_bluebirdLstC2()).default.resolve();
    }
}
exports.Target = Target;
function createTargets(nameToTarget, rawList, outDir, packager, cleanupTasks) {
    const result = [];
    const mapper = (name, factory) => {
        let target = nameToTarget.get(name);
        if (target == null) {
            target = factory(outDir);
            nameToTarget.set(name, target);
        }
        result.push(target);
    };
    const targets = normalizeTargets(rawList == null || rawList.length === 0 ? packager.platformSpecificBuildOptions.target : rawList, packager.defaultTarget);
    packager.createTargets(targets, mapper, cleanupTasks);
    return result;
}
function normalizeTargets(targets, defaultTarget) {
    if (targets == null) {
        return defaultTarget;
    }
    const list = [];
    for (const t of Array.isArray(targets) ? targets : [targets]) {
        const name = t.toLowerCase().trim();
        if (name === DEFAULT_TARGET) {
            list.push.apply(list, _toConsumableArray(defaultTarget));
        } else {
            list.push(name);
        }
    }
    return list;
}
function createCommonTarget(target, outDir, packager) {
    if (archiveTargets.has(target)) {
        return new ArchiveTarget(target, outDir, packager);
    } else if (target === "dir") {
        return new NoOpTarget("dir");
    } else {
        throw new Error(`Unknown target: ${ target }`);
    }
}
class NoOpTarget extends Target {
    build(appOutDir, arch) {
        // no build

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {})();
    }
}
exports.NoOpTarget = NoOpTarget;
class ArchiveTarget extends Target {
    constructor(name, outDir, packager) {
        super(name);
        this.outDir = outDir;
        this.packager = packager;
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const packager = _this.packager;
            const isMac = packager.platform === (_metadata || _load_metadata()).Platform.MAC;
            const outDir = _this.outDir;
            const format = _this.name;
            (0, (_log || _load_log()).log)(`Building ${ isMac ? "macOS " : "" }${ format }`);
            // we use app name here - see https://github.com/electron-userland/electron-builder/pull/204
            const outFile = function () {
                switch (packager.platform) {
                    case (_metadata || _load_metadata()).Platform.MAC:
                        return _path.join(appOutDir, packager.generateName2(format, "mac", false));
                    case (_metadata || _load_metadata()).Platform.WINDOWS:
                        return _path.join(outDir, packager.generateName(format, arch, false, "win"));
                    case (_metadata || _load_metadata()).Platform.LINUX:
                        return _path.join(outDir, packager.generateName(format, arch, true));
                    default:
                        throw new Error(`Unknown platform: ${ packager.platform }`);
                }
            }();
            const dirToArchive = isMac ? _path.join(appOutDir, `${ packager.appInfo.productFilename }.app`) : appOutDir;
            if (format.startsWith("tar.")) {
                yield (0, (_archive || _load_archive()).tar)(packager.config.compression, format, outFile, dirToArchive, isMac);
            } else {
                yield (0, (_archive || _load_archive()).archive)(packager.config.compression, format, outFile, dirToArchive);
            }
            packager.dispatchArtifactCreated(outFile, isMac ? packager.generateName2(format, "mac", true) : packager.generateName(format, arch, true, packager.platform === (_metadata || _load_metadata()).Platform.WINDOWS ? "win" : null));
        })();
    }
}
//# sourceMappingURL=targetFactory.js.map